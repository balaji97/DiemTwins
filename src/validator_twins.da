from validator import Validator
from logger_util import LOGGER

class ValidatorTwins(process, Validator):

    '''Procedure start event processing(M)'''
    def run():
        self.pacemaker.start_timer(1)

        self.process_new_round_event(None)

        # We wait for the validator to complete n_rounds + 3 as per the design
        if await(self.pacemaker.current_round >= config['nrounds'] + 3):
            pass
        elif timeout(4 * (config['nrounds'] + 3) * config['delta']):
            pass

        self.pacemaker.stop_timer(self.pacemaker.current_round)

        # Once we are done executing all rounds, we send 'Done' message to all validators
        all_validators = set()
        for to_validator in [validator_map[to_twin_id] for to_twin_id in validator_map]:
            all_validators = all_validators.union(to_validator)
            super().send(('Done',), to=to_validator)

        # We wait for other validators to be Done, in case we have to process any sync-up requests
        await(each(v in all_validators, has=received(('Done',), from_=v)))
        super().send(('Done',), to=parent())

    def send(payload, to):
        to_validator_ids = to
        message_type, message = payload

        LOGGER.log_action("Simulating network partition while sending message.", (message_type, self.pacemaker.current_round))

        to_validator_twin_ids = []
        for to_validator_id in to_validator_ids:
            if to_validator_id in test_case.twin_ids:
                to_validator_twin_ids += [str(to_validator_id), str(to_validator_id) + "_twin"]
            else:
                to_validator_twin_ids += [str(to_validator_id)]

        if not should_partition(message_type, self.pacemaker.current_round):
            # Send the message to all recipients without applying filtering logic
            LOGGER.log_action("Not applying network partition logic", (message_type, self.pacemaker.current_round))
            for to_validator in [validator_map[to_twin_id] for to_twin_id in to_validator_twin_ids]:
                super().send(payload, to=to_validator)
        else:
            # Only send to the twin_ids part of the current partition
            leader_partition_scenario = test_case.leader_partitions[pacemaker.current_round - 1]

            LOGGER.log_action("Leader partition scenario for current round.", leader_partition_scenario)

            current_partition = []
            dropped_messages = []

            for partition in leader_partition_scenario.partitions:
                network_partition = partition.partitions

                if twin_id in network_partition:
                    current_partition = network_partition
                    dropped_messages = partition.dropped_messages
                    break

            if message_type in dropped_messages:
                # Intra partition message drop
                LOGGER.log_action("Dropping message due to intra-partition message drop", message_type)
                return

            for to_validator_twin_id in to_validator_twin_ids:
                # Send to all recipients who are in the same partition
                if to_validator_twin_id in current_partition:
                    to_validator = validator_map[to_validator_twin_id]
                    super().send(payload, to=to_validator)
                else:
                    LOGGER.log_action("Dropping message to validator due to network partition", to_validator_twin_id)


    def should_partition(message_type, round_num):

        if round_num > test_case.n_rounds or message_type not in {'Proposal', 'Vote', 'Timeout'}:
            return False

        if message_type in {'Proposal', 'Vote'}:
            return True
        else:
            # Else, message type is Timeout
            # If we have not sent a timeout message for this round, return True, else False
            ans = round_num not in self.timed_out_rounds
            self.timed_out_rounds.add(round_num)

            return ans
