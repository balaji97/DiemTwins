from block_tree import BlockTree
from cryptography import Cryptography
from leader_election import LeaderElection
from ledger import Ledger
from logger_util import LOGGER
from mem_pool import MemPool
from object_types import ProposalMsg
from pacemaker import Pacemaker
from safety import Safety


class Validator (process):

    def setup(config, validator_id: int, private_key, public_keys_validators, twin_id, test_case, validator_map):
        config_id = config['config_id']
        self.timed_out_rounds = set()

        LOGGER.process_id = "validator_" + twin_id
        LOGGER.filename = '../logs/config' + str(config_id) + '/' \
            + LOGGER.process_id + ".log"

        LOGGER.log_action("Initial configuration", config)

        self.validator_ids = [i for i in range(config['nvalidators'])]

        self.id_block = dict()
        self.request_cache = dict()
        self.recently_committed_block_ids = list()

        self.ledger = Ledger(
            config_id, twin_id, self.id_block, self.recently_committed_block_ids, self.request_cache)
        self.blocktree = BlockTree(
            validator_id, self.ledger, config['nfaulty'], self.id_block)
        self.safety = Safety(validator_id,
                             self.ledger, self.blocktree)
        self.pacemaker = Pacemaker(
            validator_id, self.blocktree, self.safety, config['nfaulty'], config['delta'], send_timeout_msg)
        self.mempool = MemPool(twin_id, pacemaker, test_case.n_rounds)
        self.leader_election = LeaderElection(config['leaders'], config['default_leader'])

        Cryptography.private_key = self.private_key
        Cryptography.public_keys_validators = self.public_keys_validators

        self.proposal_msg_cache = dict()
        self.block_cache = dict()

    # Broadcast the timeout message
    def send_timeout_msg(timeout_msg):
        LOGGER.log('Validator: send_timeout_message', timeout_msg)
        send(('Timeout', timeout_msg), to=self.validator_ids)
        LOGGER.log_event('Sent', 'Timeout', timeout_msg, self.validator_ids)

    '''Procedure process certificate qc(qc)'''
    def process_certificate_qc(qc):
        LOGGER.log('Validator: process_certificate_qc', qc)

        '''Block-Tree.process qc(qc)'''
        self.blocktree.process_qc(qc)

        LOGGER.log('Validator: process_certificate_qc recent_committed_block', len(
            self.recently_committed_block_ids))

        # Move recently committed blocks to request cache
        if len(self.recently_committed_block_ids) > 0:
            for block_id in self.recently_committed_block_ids:
                for txn in self.id_block[block_id].payload:
                    self.request_cache[txn['req_id']] = {}
            self.recently_committed_block_ids.clear()

        '''Pacemaker.advance round(qc.vote info.round)'''
        self.pacemaker.advance_round_qc(qc)

        LOGGER.log('Validator: process_certificate_qc ended', qc)

    '''Procedure process new round event(last tc)'''
    def process_new_round_event(last_tc):
        LOGGER.log('Validator: process_new_round_event', last_tc)

        '''if u = LeaderElection.get leader(Pacemaker.current round) then'''
        if self.validator_id == self.leader_election.get_leader(self.pacemaker.current_round):

            '''b ← Block-Tree.generate block( MemPool.get transactions(),
                    Pacemaker.current round )'''
            block = self.blocktree.generate_block(
                self.mempool.get_transactions(), self.pacemaker.current_round)
            LOGGER.log_action('Created a new block', block)

            '''broadcast ProposalMsghb, last tc, Block-Tree.high commit qci'''
            proposal_msg = ProposalMsg(
                block=block,
                last_round_tc=last_tc,
                high_commit_qc=self.blocktree.high_commit_qc,
                validator_id=validator_id
            )
            send(('Proposal', proposal_msg), to=self.validator_ids)
            LOGGER.log_event("Sent", "Proposal",
                             proposal_msg, self.validator_ids)

        LOGGER.log("Validator: process_new_round_event ends", None)

    # Takes in as input a block and qc that we need to add to our block-tree as part of sync up
    # First makes sure we have received all previous blocks, then adds the received block to blocktree
    def sync_up_block(to_process, block):
        self.block_cache[block.id] = block

        if block.qc is not None:
            parent_block_id = block.qc.vote_info.id
        else:
            parent_block_id = None

        if parent_block_id is not None and parent_block_id not in self.block_cache:
            do_sync_up(to_process, parent_block_id)

        if block.qc is not None:
            process_certificate_qc(block.qc)

        self.blocktree.execute_and_insert(block)

    # Takes as input a block_id that we did not receive, and need to sync up to
    # Requests the parent process to send the missing blocks and complete sync up
    def do_sync_up(to_process, block_id):
        LOGGER.log_action("Requesting sync_up", block_id)

        super().send(('SyncUpRequest', block_id), to=to_process)
        --SyncUpResponse
        if await(block_id in self.block_cache):
            pass
        elif timeout(4*self.config['delta']):
            pass

    # Checks if the hash matches
    def verify_hash(data, hash):
        return Cryptography.hash(data) == hash

    '''Procedure process proposal msg(P)'''
    def receive(msg=('Proposal', proposal_msg), from_=p):
        LOGGER.log_event("Received", "Proposal", proposal_msg, p)

        signature_verified = Cryptography.get_verified_message(
            proposal_msg.signature, public_keys_validators[proposal_msg.sender])

        if signature_verified is not None and verify_hash(proposal_msg.block.id, signature_verified):
            LOGGER.log_action("Verified ProposalMsg signature", True)

            parent_block_id = None
            if proposal_msg.block.qc is not None:
                parent_block_id = proposal_msg.block.qc.vote_info.id

            # If we have not yet received the parent block. We need to sync up to that block id
            if parent_block_id is not None and parent_block_id not in self.block_cache:
                do_sync_up(p, parent_block_id)

            self.block_cache[proposal_msg.block.id] = proposal_msg.block

            if proposal_msg.block.qc is not None and self.validator_id != proposal_msg.sender:
                '''process certificate qc(P.block.qc)'''
                process_certificate_qc(proposal_msg.block.qc)

            if proposal_msg.high_commit_qc is not None:
                '''process certificate qc(P.high commit qc)'''
                process_certificate_qc(proposal_msg.high_commit_qc)

            '''Pacemaker.advance round tc(P.last round tc)'''
            self.pacemaker.advance_round_tc(proposal_msg.last_round_tc)

            '''round ← Pacemaker.current round'''
            round = self.pacemaker.current_round
            '''leader ← LeaderElection.get leader(current round)'''
            leader = self.leader_election.get_leader(round)
            '''if P.block.round 6= round ∨ P.sender 6= leader ∨ P.block.author 6= leader then
                    return'''
            if proposal_msg.block.round != round or proposal_msg.sender != leader or proposal_msg.block.author != leader:
                LOGGER.log("ROUND PROPOSAL EARLY EXIT", proposal_msg.block.round, round, proposal_msg.sender, leader)
                return

            '''Block-Tree.execute and insert(P) // Adds a new speculative state to the Ledger'''
            self.blocktree.execute_and_insert(proposal_msg.block)

            '''vote msg ← Safety.make vote(P.block, P.last round tc)'''
            vote_msg = self.safety.make_vote(
                proposal_msg.block, proposal_msg.last_round_tc)

            '''if vote msg != ⊥ then
                    send vote msg to LeaderElection.get leader(current round + 1)'''
            if vote_msg is not None:
                next_leader_id = self.leader_election.get_leader(round + 1)
                send(('Vote', vote_msg),
                     to=[next_leader_id])
                LOGGER.log_event("Sent", "Vote", vote_msg, next_leader_id)

        else:
            LOGGER.log_action("Verified ProposalMsg signature", False)

    '''Procedure process vote msg(M)'''
    def receive(msg=('Vote', vote_msg), from_=p):
        LOGGER.log_event("Received", "Vote", vote_msg, p)

        signature_verified = Cryptography.get_verified_message(
            vote_msg.signature, public_keys_validators[vote_msg.sender])

        if signature_verified is not None and verify_hash(vote_msg.ledger_commit_info, signature_verified):
            LOGGER.log_action("Verified VoteMsg signature", True)

            # If we have not yet received the block being voted on, need to sync up
            if vote_msg.vote_info.id not in self.block_cache:
                do_sync_up(p, vote_msg.vote_info.id)

            '''qc ← Block-Tree.process vote(M)'''
            qc = self.blocktree.process_vote(vote_msg)
            '''if qc != ⊥ then'''
            if qc is not None:
                LOGGER.log_action("Generated a Quorum Certificate", qc)
                '''process certificate qc(qc)
                process new round event(⊥)'''
                process_certificate_qc(qc)
                process_new_round_event(None)
        else:
            LOGGER.log_action("Verified VoteMsg signature", False)

        LOGGER.log("Received VoteMsg ends g", None)

    '''Procedure process timeout msg(M)'''
    def receive(msg=('Timeout', timeout_msg), from_=p):
        LOGGER.log_event("Received", "Timeout", timeout_msg, p)

        signature_verified = Cryptography.get_verified_message(
            timeout_msg.tmo_info.author_signature, public_keys_validators[timeout_msg.tmo_info.author])

        if timeout_msg.tmo_info.high_qc is None:
            tmo_sign_message = str(timeout_msg.tmo_info.round) + "," + str(None)
        else:
            tmo_sign_message = str(timeout_msg.tmo_info.round) + "," + str(timeout_msg.tmo_info.high_qc.vote_info.round)

        if signature_verified is not None and verify_hash(tmo_sign_message, signature_verified):
            LOGGER.log_action("Verified TimeoutMsg signature", True)

            last_block_id = None
            if timeout_msg.tmo_info.high_qc is not None:
                last_block_id = timeout_msg.tmo_info.high_qc.vote_info.id

            if last_block_id is not None and last_block_id not in self.block_cache:
                do_sync_up(p, last_block_id)

            '''process certificate qc(M.tmo info.high qc)
            process certificate qc(M.high commit qc)'''
            process_certificate_qc(timeout_msg.tmo_info.high_qc)
            process_certificate_qc(timeout_msg.high_commit_qc)

            '''Pacemaker.advance round tc(M.last round tc)'''
            self.pacemaker.advance_round_tc(timeout_msg.last_round_tc)

            '''tc ← Pacemaker.process remote timeout(M)'''
            tc = self.pacemaker.process_remote_timeout(timeout_msg)
            '''if tc != ⊥ then'''
            if tc is not None:
                LOGGER.log_action("Generated a Timeout Certificate", tc)
                '''process certificate qc(qc)
                process new round event(⊥)'''
                self.pacemaker.advance_round_tc(tc)
                process_new_round_event(tc)
        else:
            LOGGER.log_action("Verified TimeoutMsg signature", False)

    def receive(msg=('SyncUpRequest', block_id), from_=p):
        LOGGER.log_action("Received sync_up request", block_id)
        super().send(('SyncUpResponse', self.block_cache[block_id]), to=p)

    def receive(msg=('SyncUpResponse', block), from_=p):
        LOGGER.log_action("Received sync_up", block.id)
        sync_up_block(p, block)

